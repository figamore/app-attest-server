const crypto = require('crypto');
const { X509Certificate } = require('node:crypto');
const { AsnConvert } = require('@peculiar/asn1-schema');
const { Certificate } = require('@peculiar/asn1-x509');
const decodeCborObject = require('./utils/CBORDecoder');
const { computeSHA256, computeSHA256Base64 } = require('./utils/SHA256Compute');
const dbQuery = require('./utils/SQLiteHelper');



//Official Apple Root Certificate. Found here: https://www.apple.com/certificateauthority/Apple_App_Attestation_Root_CA.pem
const Apple_App_Attestation_Root_CA = `-----BEGIN CERTIFICATE-----
MIICITCCAaegAwIBAgIQC/O+DvHN0uD7jG5yH2IXmDAKBggqhkjOPQQDAzBSMSYw
JAYDVQQDDB1BcHBsZSBBcHAgQXR0ZXN0YXRpb24gUm9vdCBDQTETMBEGA1UECgwK
QXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTAeFw0yMDAzMTgxODMyNTNa
Fw00NTAzMTUwMDAwMDBaMFIxJjAkBgNVBAMMHUFwcGxlIEFwcCBBdHRlc3RhdGlv
biBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJbmMuMRMwEQYDVQQIDApDYWxpZm9y
bmlhMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAERTHhmLW07ATaFQIEVwTtT4dyctdh
NbJhFs/Ii2FdCgAHGbpphY3+d8qjuDngIN3WVhQUBHAoMeQ/cLiP1sOUtgjqK9au
Yen1mMEvRq9Sk3Jm5X8U62H+xTD3FE9TgS41o0IwQDAPBgNVHRMBAf8EBTADAQH/
MB0GA1UdDgQWBBSskRBTM72+aEH/pwyp5frq5eWKoTAOBgNVHQ8BAf8EBAMCAQYw
CgYIKoZIzj0EAwMDaAAwZQIwQgFGnByvsiVbpTKwSga0kP0e8EeDS4+sQmTvb7vn
53O5+FRXgeLhpJ06ysC5PrOyAjEAp5U4xDgEgllF7En3VcE3iexZZtKeYnpqtijV
oyFraWVIyd/dganmrduC1bmTBGwD
-----END CERTIFICATE-----`




const extractCredCertificates = (decodedObject) => {
    try {
        const credCertBuffer = decodedObject['attStmt']['x5c'][0]   //credCert
        const caCertBuffer = decodedObject['attStmt']['x5c'][1]   //caCert

        const credCert = new X509Certificate(credCertBuffer);
        const caCert = new X509Certificate(caCertBuffer);
        const appleCert = new crypto.X509Certificate(Apple_App_Attestation_Root_CA)

        credCert.verify(caCert.publicKey)
        caCert.verify(appleCert.publicKey);
        return credCert
    } catch (error) {
        console.error('Error: Certificate Error')
        console.error(error)
        return false
    }
}

function getExtensionValue(certBuffer, oid = "1.2.840.113635.100.8.2") {
    // Parse the DER-encoded certificate
    const cert = AsnConvert.parse(certBuffer, Certificate);
    const extensions = cert.tbsCertificate.extensions || [];
    const extension = extensions.find(ext => ext.extnID === oid);
    return extension && extension.extnValue;
}


/**
 * Validates a new device attestation according to Apple App Attest specification.
 * 
 * This function performs the complete Apple App Attest validation flow:
 * 1. Verifies certificate chain against Apple's root CA
 * 2. Validates client data hash and composite nonce
 * 3. Checks extension values in the credential certificate
 * 4. Verifies public key hash matches the provided keyId
 * 5. Validates App ID hash against RP ID
 * 6. Ensures counter starts at zero
 * 7. Validates AAGUID for development/production environment
 * 8. Confirms credential ID matches key identifier
 *
 * @param {string} attestationNonce - Base64-encoded challenge nonce generated by server
 * @param {string} keyId - Base64-encoded SHA256 hash of the public key from client
 * @param {string} rawAttestObject - Base64url-encoded CBOR attestation object from client
 * @param {string} teamId - 10-character alphanumeric Apple Developer Team ID
 * @param {string} bundleIdentifier - App bundle identifier in reverse domain format (e.g., com.company.app)
 * @param {boolean} [DEV_MODE=false] - Set to true for development builds, false for production
 * 
 * @returns {Object} Validation result object
 * @returns {boolean} returns.result - True if validation successful, false otherwise
 * @returns {string} [returns.publicKeyPEM] - PEM-encoded public key if validation successful
 * @returns {string} [returns.reason] - Detailed error message if validation failed
 * 
 * @example
 * const result = validateAttestation(
 *   'base64-nonce',
 *   'base64-keyId', 
 *   'base64url-attestation-object',
 *   '1234567890',
 *   'com.example.app',
 *   false
 * );
 * 
 * if (result.result) {
 *   console.log('Attestation valid:', result.publicKeyPEM);
 * } else {
 *   console.error('Attestation failed:', result.reason);
 * }
 * 
 * @throws {Error} May throw on critical system errors (file system, crypto operations)
 */
const validateAttestation = (attestationNonce, keyId, rawAttestObject, teamId, bundleIdentifier, DEV_MODE = false) => {

    if (!attestationNonce || !keyId || !rawAttestObject || !teamId || !bundleIdentifier) {
        return {
            result: false,
            reason: 'Missing required parameters: attestationNonce, keyId, rawAttestObject, teamId, bundleIdentifier'
        }
    }

    if (typeof teamId !== 'string' || teamId.length !== 10) {
        return {
            result: false,
            reason: 'Team ID must be a 10-character string'
        }
    }

    if (typeof bundleIdentifier !== 'string' || !bundleIdentifier.includes('.')) {
        return {
            result: false,
            reason: 'Bundle identifier must be a valid reverse domain string'
        }
    }

    //1. Verify that the x5c array contains the intermediate and leaf certificates for App Attest,
    // starting from the credential certificate in the first data buffer in the array (credcert). 
    //Verify the validity of the certificates using Apple’s App Attest root certificate.
    const decodedAttestObject = decodeCborObject(rawAttestObject)
    const extractedCredCert = extractCredCertificates(decodedAttestObject)

    if (!extractedCredCert) return {
        result: false,
        reason: 'Invalid certificate chain.'
    }


    //2. Create clientDataHash as the SHA256 hash of the one-time challenge your server
    // sends to your app before performing the attestation, and append that hash to the
    // end of the authenticator data (authData from the decoded object).
    const clientDataHash = computeSHA256(Buffer.from(attestationNonce, 'base64'))       //TODO: May remove 'base64', depending on how it was done in Swift
    const authData = decodedAttestObject.authData
    const compositeItem = Buffer.concat([authData, clientDataHash])


    //3. Generate a new SHA256 hash of the composite item to create nonce.
    const compositeNonce = computeSHA256(compositeItem)


    //4. Obtain the value of the credCert extension with OID 1.2.840.113635.100.8.2,
    // which is a DER-encoded ASN.1 sequence. Decode the sequence and extract the
    // single octet string that it contains. Verify that the string equals nonce.
    const compareAttestNonce = (extensionValue, compositeNonce) => {
        const octetString = Buffer.from(extensionValue.buffer).toString('hex').substring(12)
        return octetString === compositeNonce.toString('hex')
    }

    const credCert = decodedAttestObject['attStmt']['x5c'][0]
    const extensionValue = getExtensionValue(credCert)
    const nonceMatch = compareAttestNonce(extensionValue, compositeNonce)

    if (!nonceMatch) return {
        result: false,
        reason: 'credCert octet string does not match nonce.'
    }


    //5. Create the SHA256 hash of the public key in credCert, and verify that it matches the key identifier from your app.
    const publicKeyRaw = extractedCredCert.publicKey.export({ type: 'spki', format: 'der' }) //DER-encoded PKCS#8 public key
    const credCertPublicKey = publicKeyRaw.slice(26)
    const credCertPublicKeyPem = extractedCredCert.publicKey.export({ type: 'spki', format: 'pem' })
    const credCertPublicKeyHash = computeSHA256Base64(credCertPublicKey)

    if (credCertPublicKeyHash !== keyId) return {
        result: false,
        reason: 'SHA256 hash of public key in credCert does not match app key identifier.'
    }


    //6. Compute the SHA256 hash of your app’s App ID, and verify that it’s the same as the authenticator data’s RP ID hash.
    const rpId = decodedAttestObject.authData.slice(0, 32)
    const appIdHash = computeSHA256(teamId + '.' + bundleIdentifier)

    if (rpId.toString('hex') !== appIdHash.toString('hex')) return {
        result: false,
        reason: `Authenticator data's RP ID hash does not match SHA256 hash of your App ID`
    }


    //7. Verify that the authenticator data’s counter field equals 0.
    const dataCounter = decodedAttestObject.authData.slice(33, 37).toString('hex')

    if (dataCounter !== '00000000') return {
        result: false,
        reason: 'Authenticator data counter is not zero'
    }


    //8. Verify that the authenticator data’s aaguid field is either appattestdevelop if
    // operating in the development environment, or appattest followed by seven 0x00 bytes
    // if operating in the production environment.
    const aaguidField = decodedAttestObject.authData.slice(37, 37 + 16).toString('hex')

    const AAGUID_DEVELOP = '617070617474657374646576656c6f70'
    const AAGUID_PRODUCTION = '61707061747465737400000000000000'

    if (DEV_MODE && aaguidField !== AAGUID_DEVELOP) {
        return {
            result: false,
            reason: 'Development mode requires development AAGUID.'
        }
    }

    if (!DEV_MODE && aaguidField !== AAGUID_PRODUCTION) {
        return {
            result: false,
            reason: 'Production mode requires production AAGUID.'
        }
    }

    if (aaguidField !== AAGUID_PRODUCTION && aaguidField !== AAGUID_DEVELOP) return {
        result: false,
        reason: 'Invalid aaguid field.'
    }


    //9. Verify that the authenticator data’s credentialId field is the same as the key identifier.
    const credentialIdField = decodedAttestObject.authData.slice(39 + 16, 39 + 16 + 32).toString('base64')
    const credentialIdFieldMatchesKeyId = credentialIdField === keyId

    if (!credentialIdFieldMatchesKeyId) return {
        result: false,
        reason: 'Authenticator data credentialId field does not match key identifier'
    }

    return {
        result: true,
        publicKeyPEM: credCertPublicKeyPem,
    }
}


/**
 * Generates a cryptographically secure nonce for device attestation.
 * 
 * This function creates a challenge nonce that the client must include in their
 * attestation request. It also clears any existing attestation data for the device
 * and initializes a new attestation record in the database.
 *
 * @param {Object} req - Express.js request object
 * @param {Object} req.headers - Request headers
 * @param {string} req.headers['device-id'] - Unique device identifier from client
 * 
 * @returns {Promise<string|Object>} Base64-encoded nonce string on success, or error object on failure
 * @returns {string} [returns.error] - Error message if nonce generation failed
 * 
 * @example
 * // Express route handler
 * app.get('/api/nonce', async (req, res) => {
 *   const nonce = await getNonce(req);
 *   if (nonce?.error) {
 *     return res.status(400).json({ error: 'Failed to generate nonce' });
 *   }
 *   return res.json({ nonce });
 * });
 * 
 * @throws {Error} May throw on database connection or crypto operation errors
 */
const getNonce = async (req) => {
    try {
        const deviceId = req.headers['device-id']
        await dbQuery(`DELETE FROM attestations WHERE deviceId = ?`, [deviceId])
        const randomNonce = crypto.randomBytes(24).toString('base64')
        await dbQuery(`INSERT into attestations (deviceId, nonce, counter) VALUES (?, ?, 0)`, [deviceId, randomNonce])
        return randomNonce
    } catch (error) {
        console.error('Error generating nonce: ', error)
        return { error: error }
    }
}

module.exports = { validateAttestation, getNonce }
